## Архитектура и структура кода

Код разбит на модули так, чтобы пайплайн был:

* модульным (каждая проверка — отдельный компонент),
* тестируемым (можно тестировать чтение, валидации, дедуп, novelty отдельно),
* расширяемым (новые проверки и метрики добавляются без переписывания всего пайплайна).

### Общая идея

* `cli/` — только консольный интерфейс, без логики валидаций.

* `pipeline/runner.py` — главный оркестратор, который вызывает модули в правильном порядке.

* `io/`, `validation/`, `analysis/`, `dedup/`, `novelty/`, `report/` — изолированные блоки логики.

* `ui/` — веб-интерфейс, который использует тот же `run_validation(...)`, что и CLI.

---

## `scripts/` — вспомогательные скрипты запуска

### `scripts/run_validation.sh`

Запускает валидацию для набора моделей (MatterGen / Con-CDVAE / CrystalFormer и т.д.).

### `scripts/run_docker.sh`

Запускает тот же `scripts/run_validation.sh`, но внутри Docker.

## `cli/` - CLI интерфейс

## `cli/app.py`

CLI-обёртка над пайплайном:

- принимает аргументы (`--input-dir`, `--out-dir`, `--thresholds`, `--train-reference`, `--model-name`)

- загружает конфиг из YAML (или берёт дефолты)

- вызывает `run_validation(...)`

- печатает итоговый отчёт (`validation_report.json`) в консоль

## `ui/` — Streamlit интерфейс

UI — это отдельный слой, который не дублирует логику пайплайна. Он:

- запускает `run_validation(...)`

- читает `outputs/*/validation_report.json` и `all_structures.csv`

- даёт фильтры и просмотр структуры (включая 3D)

** `ui/app.py`

Точка входа Streamlit-приложения:

- настраивает страницу

- рисует базовую “главную” страницу

- подключает экраны из `ui/views/`

## `ui/views/`

Экраны интерфейса. Обычно:

- `run_view.py` — форма запуска пайплайна

- `explore_view.py` — просмотр `all_structures.csv`, фильтры, карточка структуры, 3D viewer

- `compare_view.py` — сравнение моделей по `validation_report.json`

Каждый view — это “render-функция”, которая строит UI, но не реализует бизнес-логику валидации.

## `ui/lib/`

Общие утилиты для UI, чтобы не размазывать код по views:

- `fs.py` — поиск запусков в `outputs/`, чтение `report.json`, сбор индекса запусков

- `data.py` — загрузка и нормализация `all_structures.csv` (типы, булевые, числовые), фильтрация

- `viz.py` — визуализация структуры

## Корень пакета `mvpipeline/`

### `__init__.py`

Служебный файл пакета (версия, экспорт публичных API, при необходимости).

### `config.py`

Единое место для параметров пайплайна (порогов и переключателей).

Примеры того, что хранится в конфиге:

* `min_distance`, `max_distance`
* `min_density`, `max_density`
* `min_volume_per_atom`, `max_volume_per_atom`
* `max_atoms`
* список магнитных элементов
* параметры `StructureMatcher` (tolerances)
* режимы строгости (например, что делать при невозможности определить заряд)

***Данные берутся с thresholds.yaml***

Цель: чтобы настройки менялись централизованно, без поиска констант по коду.

### `constants.py`

Константы проекта, которые должны быть стабильными:

* коды причин отклонения (строки, которые попадут в `rejection_reasons` и reason.json)
* дефолтный список магнитных элементов
* дефолтные значения порогов (если не задаются в конфиге)

Важно: коды причин отклонения — часть “публичного интерфейса” отчёта, их нельзя менять произвольно.

### `types.py`

Общие типы данных (dataclasses / TypedDict), которые используются между модулями.

Например:

* описание входного файла (`structure_id`, `path`)
* результат проверки (`status`, `reason`, `details`)
* вычисленные дескрипторы (`density`, `volume_per_atom`, `n_atoms`, …)

Цель: чтобы модули не обменивались “сырыми dict” и была единая структура данных.

### `logging.py`

Настройка логов (обычно через `rich`):

* формат сообщений,
* уровень логирования (verbose/non-verbose),
* единый logger для всех модулей.

---

## `io/` — работа с файловой системой (ввод/вывод)

### `io/discover.py`

Отвечает за поиск CIF-файлов.

* рекурсивно находит `*.cif` в `input_dir`
* формирует `structure_id`

### `io/cif_reader.py`

Отвечает за безопасное чтение CIF.

* читает файл и возвращает объект структуры (например, `pymatgen.Structure`)
* ловит ошибки и возвращает “понятную” причину (`cif_parse_error`)

### `io/writers.py`

Отвечает за сохранение результатов.

* копирует валидные CIF в `validated_structures/`
* копирует отклонённые CIF в `rejected_structures/`
* создаёт `*.reason.json` рядом с отклонёнными

Цель: все операции записи на диск находятся в одном месте.

---

## `validation/` — правила, которые могут отклонить структуру

Это набор проверок, каждая в своём модуле. Каждая проверка возвращает либо “ok”, либо причину отклонения + детали.

### `validation/cif_sanity.py`

Быстрые sanity-checks структуры после парсинга:

* структура не пустая
* корректная решётка
* координаты атомов корректны

### `validation/geometry.py`

Геометрические ограничения:

* min/max расстояния между атомами
* min/max объём на атом

Главная цель — отсеять физически невозможные структуры.

### `validation/chemistry.py`

Химическая проверка:

* charge neutrality (в best-effort режиме или строгом — зависит от конфигурации)

Если удаётся определить заряд и он не ноль → отклоняем.

### `validation/magnetism.py`

Проверка “магнитности по составу”:

* определяет, есть ли в структуре магнитные элементы (Fe/Co/Ni/Mn/Cr/V…)
* **не отклоняет**, используется только для метрики `magnetic_ratio`.

---

## `analysis/` — вычисление свойств и “фичей” структуры

### `analysis/descriptors.py`

Считает базовые дескрипторы для отчёта:

* `density`
* `volume_per_atom`
* `n_atoms`
* `reduced_formula` (если используется)

### `analysis/spacegroup.py`

Модуль для определения пространственной группы (space group) структуры.

---

## `dedup/` — удаление дубликатов

### `dedup/matcher.py`

Определяет, является ли структура дубликатом уже принятой.

* использует `pymatgen.analysis.structure_matcher.StructureMatcher`
* хранит набор уже валидированных структур (или индекс по “бакетам”)
* на вход получает структуру и возвращает:

  * duplicate / not duplicate
  * (опционально) с чем совпало

Если duplicate → структура отклоняется с причиной `duplicate`.

---

## `novelty/` — проверка новизны относительно train dataset

### `novelty/train_reference.py`

Загрузка и индексирование `train_reference.csv`:

* читает CSV
* строит быстрый lookup (например, set ключей)
* даёт функцию проверки новизны

Novelty считается по `reduced_formula` (или по формуле, если spacegroup отсутствует в train).

Важно: novelty — **метрика**, а не причина отклонения (по умолчанию).

---

## `report/` — отчёты и артефакты анализа

### `report/records.py`

Формирует и записывает общий CSV со всеми структурами: `all_structures.csv`.

Зачем он нужен:
* чтобы после одного запуска получить единый датасет для анализа
* строить графики распределений (density/vpa/min_distance)
* сравнивать генераторы (MatterGen vs Con-CDVAE и т.д.)

Что содержит CSV (ключевые поля):

* `structure_id`, `input_path`
* `status` (validated/rejected)
* `rejection_reason` (если rejected)
* флаги качества/метрик: `is_suspicious`, `is_duplicate`, `is_novel`, `is_magnetic`
* дескрипторы: `n_atoms`, `density`, `volume_per_atom`, `reduced_formula`, `spacegroup`, `min_distance`
* `charge_solution_json` — найденные степени окисления (если удалось подобрать)
* `details_json` — полный JSON с деталями проверок (чтобы ничего не потерять)

---

## `pipeline/` — сборка всего в единый конвейер

### `pipeline/runner.py`

Главный оркестратор, который выполняет pipeline по шагам:

1. найти все CIF (`io.discover`)
2. загрузить train_reference (`novelty.train_reference`)
3. для каждого CIF:

   * прочитать CIF (`io.cif_reader`)
   * sanity-check (`validation.cif_sanity`)
   * геометрия (`validation.geometry`)
   * плотность/ограничения (там же или в geometry/analysis, зависит от реализации)
   * дескрипторы (`analysis.descriptors`)
   * magnetic flag (`validation.magnetism`)
   * дедуп (`dedup.matcher`)
   * novelty (`novelty.train_reference`)
   * сохранить в validated/rejected (`io.writers`)
   * обновить агрегатор отчёта (`report.aggregator`)
4. записать `validation_report.json` (`report.schema` + writers)

