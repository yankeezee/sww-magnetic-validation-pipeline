## Архитектура и структура кода

Код разбит на модули так, чтобы пайплайн был:

* модульным (каждая проверка — отдельный компонент),
* тестируемым (можно тестировать чтение, валидации, дедуп, novelty отдельно),
* расширяемым (новые проверки и метрики добавляются без переписывания всего пайплайна).

### Общая идея

* `cli.py` — только интерфейс командной строки, без логики.
* `pipeline/runner.py` — главный “оркестратор”: он связывает все компоненты.
* Пакеты `io/`, `validation/`, `analysis/`, `dedup/`, `novelty/`, `report/` — изолированные части логики, которые runner вызывает по порядку.

---

## `cli.py`

CLI-интерфейс. Здесь определяется команда:

* `mvp validate --input-dir ... --out-dir ... --train-reference ...`

`cli.py`:

* парсит аргументы,
* инициализирует конфиг и логирование,
* вызывает `pipeline.runner.run_validation(...)`.

В `cli.py` не должно быть “бизнес-логики” проверок.

## Корень пакета `mvpipeline/`

### `__init__.py`

Служебный файл пакета (версия, экспорт публичных API, при необходимости).

### `config.py`

Единое место для параметров пайплайна (порогов и переключателей).

Примеры того, что хранится в конфиге:

* `min_distance`, `max_distance`
* `min_density`, `max_density`
* `min_volume_per_atom`, `max_volume_per_atom`
* `max_atoms`
* список магнитных элементов
* параметры `StructureMatcher` (tolerances)
* режимы строгости (например, что делать при невозможности определить заряд)

***Данные берутся с thresholds.yaml***

Цель: чтобы настройки менялись централизованно, без поиска констант по коду.

### `constants.py`

Константы проекта, которые должны быть стабильными:

* коды причин отклонения (строки, которые попадут в `rejection_reasons` и reason.json)
* дефолтный список магнитных элементов
* дефолтные значения порогов (если не задаются в конфиге)

Важно: коды причин отклонения — часть “публичного интерфейса” отчёта, их нельзя менять произвольно.

### `types.py`

Общие типы данных (dataclasses / TypedDict), которые используются между модулями.

Например:

* описание входного файла (`structure_id`, `path`)
* результат проверки (`status`, `reason`, `details`)
* вычисленные дескрипторы (`density`, `volume_per_atom`, `n_atoms`, …)

Цель: чтобы модули не обменивались “сырыми dict” и была единая структура данных.

### `logging.py`

Настройка логов (обычно через `rich`):

* формат сообщений,
* уровень логирования (verbose/non-verbose),
* единый logger для всех модулей.

---

## `io/` — работа с файловой системой (ввод/вывод)

### `io/discover.py`

Отвечает за поиск CIF-файлов.

* рекурсивно находит `*.cif` в `input_dir`
* формирует `structure_id`

### `io/cif_reader.py`

Отвечает за безопасное чтение CIF.

* читает файл и возвращает объект структуры (например, `pymatgen.Structure`)
* ловит ошибки и возвращает “понятную” причину (`cif_parse_error`)

### `io/writers.py`

Отвечает за сохранение результатов.

* копирует валидные CIF в `validated_structures/`
* копирует отклонённые CIF в `rejected_structures/`
* создаёт `*.reason.json` рядом с отклонёнными

Цель: все операции записи на диск находятся в одном месте.

---

## `validation/` — правила, которые могут отклонить структуру

Это набор проверок, каждая в своём модуле. Каждая проверка возвращает либо “ok”, либо причину отклонения + детали.

### `validation/cif_sanity.py`

Быстрые sanity-checks структуры после парсинга:

* структура не пустая
* корректная решётка
* координаты атомов корректны

### `validation/geometry.py`

Геометрические ограничения:

* min/max расстояния между атомами
* min/max объём на атом

Главная цель — отсеять физически невозможные структуры.

### `validation/chemistry.py`

Химическая проверка:

* charge neutrality (в best-effort режиме или строгом — зависит от конфигурации)

Если удаётся определить заряд и он не ноль → отклоняем.

### `validation/magnetism.py`

Проверка “магнитности по составу”:

* определяет, есть ли в структуре магнитные элементы (Fe/Co/Ni/Mn/Cr/V…)
* **не отклоняет**, используется только для метрики `magnetic_ratio`.

---

## `analysis/` — вычисление свойств и “фичей” структуры

### `analysis/descriptors.py`

Считает базовые дескрипторы для отчёта:

* `density`
* `volume_per_atom`
* `n_atoms`
* `reduced_formula` (если используется)

### `analysis/spacegroup.py`

Модуль для определения пространственной группы (space group) структуры.

---

## `dedup/` — удаление дубликатов

### `dedup/matcher.py`

Определяет, является ли структура дубликатом уже принятой.

* использует `pymatgen.analysis.structure_matcher.StructureMatcher`
* хранит набор уже валидированных структур (или индекс по “бакетам”)
* на вход получает структуру и возвращает:

  * duplicate / not duplicate
  * (опционально) с чем совпало

Если duplicate → структура отклоняется с причиной `duplicate`.

---

## `novelty/` — проверка новизны относительно train dataset

### `novelty/train_reference.py`

Загрузка и индексирование `train_reference.csv`:

* читает CSV
* строит быстрый lookup (например, set ключей)
* даёт функцию проверки новизны

Novelty считается по `reduced_formula` (или по формуле, если spacegroup отсутствует в train).

Важно: novelty — **метрика**, а не причина отклонения (по умолчанию).

---

## `report/` — итоговые метрики и формат отчёта

### `report/schema.py`

Описывает формат `validation_report.json`:

* обязательные поля и их типы
* гарантирует стабильную структуру отчёта

### `report/aggregator.py`

Собирает статистику по всем структурам:

* `n_total`, `n_validated`, `n_rejected`
* `rejection_reasons`
* средние значения дескрипторов
* доли `magnetic_ratio`, `novelty_ratio`, `duplicate_ratio`

---

## `pipeline/` — сборка всего в единый конвейер

### `pipeline/runner.py`

Главный оркестратор, который выполняет pipeline по шагам:

1. найти все CIF (`io.discover`)
2. загрузить train_reference (`novelty.train_reference`)
3. для каждого CIF:

   * прочитать CIF (`io.cif_reader`)
   * sanity-check (`validation.cif_sanity`)
   * геометрия (`validation.geometry`)
   * плотность/ограничения (там же или в geometry/analysis, зависит от реализации)
   * дескрипторы (`analysis.descriptors`)
   * magnetic flag (`validation.magnetism`)
   * дедуп (`dedup.matcher`)
   * novelty (`novelty.train_reference`)
   * сохранить в validated/rejected (`io.writers`)
   * обновить агрегатор отчёта (`report.aggregator`)
4. записать `validation_report.json` (`report.schema` + writers)

